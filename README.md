### BASIC
----### Escape последовательности
--------\b - удаление последнего выведенного символа
--------\n - перейти на начало новой строки
--------\t - перейти к следующей позиции табуляции

--------\\ - вывести обратный слэш
--------\" - вывести двойную кавычку
--------\' - вывести одинарную кавычку

----### Типы данных
--------#### Целые числа
            ```
			int
			short
			long 
            ```
--------#### Числа с плавающей запятой
			```
            float
			double
            ```
--------#### Символ
            ```
			char ''
            ```
--------#### Логический
            ```
			bool
            ```
----### const - постоянные данные
----### cin - считывает данные с консоли
----### cout - выводит в консоль

----### Операторы
--------#### Унарные
-------------(92) -> -92
--------#### Бинарные
------------Арифметические: +, -, *, /, %
--------#### Тернарные
------------? - if
------------: - else

----### system("pause") - системная функция, с аргументом "pause" консоль не закрывается сразу после запуска приложения
----### goto -  переход с одной части кода на другую (не рекомендуется использовать) - goto linkName
----### link - ссылка куда необходимо перейти - linkName:

----### Отладка
--------шаг с заходом - заход в функцию
--------шаг с обходом - переход на следующую строку (даже если строка без точки остановы)
--------переход на следующу точку остановы: Отладка -> Продолжить

----### Массивы
--------* Статические
--------* Динамические

--------* Одномерные
--------* Двумерные

--------#### Статический
------------Объявление
----------------Одномерный
--------------------тип_данных название_переменной [количество элементов] | int arr[10]
----------------Двумерный
--------------------тип_данных название_переменной [количество элементов][количество элементов] | int arr[10][20]

------------Инициализация
----------------Одномерный
--------------------* тип_данных название_переменной [] = {элемент1, элемент2} | int arr[] = {1, 1, 3, 5}
--------------------* тип_данных название_переменной []{элемент1, элемент2} | int arr[]{1, 1, 3, 5}
--------------------* тип_данных название_переменной [количество элементов]{элемент1, элемент2} | int arr[]{1, 1, 3, 5}
----------------Двумерный
--------------------* тип_данных название_переменной [количество элементов][количество элементов]{} | int arr[10][20]{}
--------------------* тип_данных название_переменной [количество элементов][количество элементов]{{элемент1, элемент2}} | int arr[10][20]{{1, 2, 3}, {4, 5, 6}}

--------#### Динамический
------------Инициализация
----------------Одномерный
--------------------тип_данных *название_указателя = new тип_данных[размер_массива] | int *arr = new int[size]
----------------Двумерный
--------------------тип данных **название_указателя = new тип_данных* [размер_массива] | int **arr = new int* [size]

--------#### Копирование
----------------Динамический
--------------------1. Очищаем динамическую память первого массива (в итоге указатель должен указывать на область памяти пустой массив или без массива, т.к. элементы массив удалены)
--------------------2. Итерируемся в цикле и на каждой итерации элемент второго массива присваиваем к элементу первого массива по индексу
--------------------3. Очищаем динамическую память второго массива

--------#### Функции
----------------sizeof(arrayName) - длина байтов типов данных/переменной, которую используем с ключевым словом

--------#### Примечание:
----------------* изначально данные в массиве мусорные данные, после добавление/изменения значения по индексу, элементы в массиве изменяются
----------------* при инициализации, в случае большего количества элементов в [] скобках, чем текущих в {} скобках, остальными элементами будут 0
----------------* массив - непрерывная область памяти
----------------* основное отличие динамического массива от статического - количество элементов в массиве. количество элементов может быть динамическим значением и изменятся в разных местах программы
----------------* в динамическом двумерном массиве хранятся указатели на массивы в динамической памяти, а не сами массивы

----### Функции
--------#### Объявление
------------тип_возвращемого_значения имя_функции(параметры)
------------{
----------------инструкции
------------}

--------#### Аргументы
------------Константные аргументы нужны для безопасности при работе с данными, нет возможности изменить значение в функции

--------#### Прототипы
------------описание: обычно добавляют сверху основного кода для обращения к функции, до ее инициализации (область видимости)
------------вид: тип_возвращемого_значения имя_функции(параметры);
------------пример: int functionName(int a);, int functionName(int a) {...}

--------#### Ключевые слова
------------inline - встраиваемая функция (оптимизация). описание: при выполнении функции компилятор не будет искать функцию в памяти, вместо этого сделает так, будто  ------------функци была описана в этом блоке кода
------------typename, class - указание типа

--------#### Перегрузка
------------описание: написание той же логики функции, но для разных типов принимаемых аргументов. функции с одинаковым названием, но с разными данными/типами на ------------и на выходе
------------пример: int functionName(int a, int b) {...}, double functionName(int a, double b, double c)

--------#### Шаблоны	
------------описание: может работать с различными типами, в том числе, которые еще не были указаны
------------пример: template <typename T> T functionName(T a, T b) {...}
------------примечание: T - условное название передаваего типа

--------#### Основные
------------sizeof(argument) - длина в байтах
------------rand() - случайное число
------------srand(int argument) -  точка, от которой отталкивается rand()
------------time(argument) - возвращает время в секундах | если передать 0 или NULL, то вернет время в секудах с 1 января 1970 года

--------#### Указатели
------------Структура: тип_функции(*имя_указателя)(спецификация_параметров)
------------Пример: void (*functionPointer)(params); -> functionPointer = someExistFunction; -> functionPointer(params);
------------Назначение: полиморфизм

--------#### Примечание
------------* при передаче массива в качестве параметра, необходимо передавать и размер массива
------------* sizeof() - будет передавать длину указателя на массив
------------* inline - может не сработать, если в функции большая логика
------------* с каждой реализацией функции перегрузки, перегрузка будет увелчиваться на 1
------------* при нескольких разных типах в шаблонной функции - template <typename T1, typename T2> T functionName(T1 a, T2 b) {...}
------------* typename и class - одинаковый функционал у клюевых слов
------------* для изменения примитивных типов данных в качестве аргумента необходимо передавать указатель или ссылку на переменную

----### Динамическая память
--------new - оператор, который выделяет динамическую память
--------delete - оператор, который убирает/очищает данные с выделенной динамической памяти
--------nullptr - тип данных, который изменяет адрес указателя

--------#### Синтаксис
------------new тип_данных
------------delete название_указателя

--------#### Примеры:
------------Работа с БД (неизвестное количество данных)

--------#### Шаги:
------------В программе хранится указатель, который указывает на определенное место в оперативной памяти, где хранятся данные

--------#### Примечание:
------------* когда не нужны данные из динамической памяти (кучи), необходимо очистить область динамической памяти
------------* для получения адреса выделенной динамической памяти необходимо использовать указатель | int *pn = new int;
------------* заполнение данных в динамическую память реализуется с помощью разыменования | *pn = 72;
------------* для удаления данных с выделенной динамической памяти необходимо название указателя | delete pn;
------------* изменить адрес, на который указывает указать можно с помощью 0, NULL, nullptr. рекомендуется nullptr | pn = nullptr;
------------* после удаления данных с динамической памяти с помощью delete, указатель будет также указывать на адрес динамической памяти, но значение переменной удалится
------------* если присвоить указателю, который ранее указывал на динамическую память, но сейчас значение по этому адресу удалено, значение NULL или 0, то указатель будет указывать на 0
------------* очистка выделенной динамической памяти: 1) delete pn;, 2) pn = nullptr; в обратном случае произойдет УТЕЧКА ОПЕРАТИВНОЙ ПАМЯТИ, т.к. адрес на который указывает указатель будет нулевым, а данные так и останутся в динамической памяти
------------* для удаления динамического массива с выделенной динамической памяти необходимо [] название указателя | delete [] pArr;

----### Указатели
--------#### Указатель (pointer) - это переменная, которая содержит |адрес в оперативной памяти| |другой переменной|

--------#### Пример
            ```
            int n = 10;
            int *pn = &n;
            ```

--------#### Синтаксис
------------ * - объявление переменной указателя

--------#### Примечание
------------* тип данных указателя должен соответствовать тому типу данных переменной, на который указывает
------------* для получения доступа к значению переменной, на который указывает указатель необходимо выполнить разыменование - *pointerName
------------* название массива - указатель на первый элемент массива


--------#### Арифметика указателей
------------при переходе между элементами массива в цикле с помощью указателя, шаг будет равен типу данных элементу массива | int - 4, char - 1

----### Ссылки
--------#### Ссылка (reference) содержит адрес переменной в оперативной памяти

--------#### Пример
            ```
            int n = 10;
            &n;
            ```

--------#### Синтаксис
------------ & - оператор получения адреса

--------#### Примечание
------------* у ссылок нет оператора разыменования, они сразу работают со значением переменной
------------* с ссылками работаем с данными напрямую
------------* ссылку необходимо обязательно инициализровать во время объявления
------------* у ссылки есть свой адрес в оперативной памяти | int n = 10; int &nRef = n; int &nRefToRef = nRef;
------------* в функцию в качестве аргумента можно передавать ссылку для изменения значения переменной во внешней области видимости

----### Строки
--------#### Строка - массив символов

--------#### Синтаксис
------------ '' - символ
------------ "" - строка

--------#### Инициализация
            ```
            char string[] = "string";
            char string[11] = "string";
            char string[] = {'s', 't', 'r', 'i', 'n', 'g', '\0'};
            char *string = "string";
            ```

--------#### Функции
------------strlen(string) - длина строки

--------#### Конкатенация
------------Конкатенация строк с оператором +
------------Пример
                ```
                string str1 = "Str";
                string str2 =  "ing";
                string word = str1 + str2;
                ```
            
--------#### Примечание:
------------* определение длины строки происходит до термирующего нуля | \0

----### Приведение типов
--------#### Преобразование типа
------------Явное
----------------(тип_данных)переменная | double n = 255.7; (int)n -> n = 255
------------Неявное (преобразование компилятором)
----------------int n = 255.72 -> n = 255

--------#### Примечание:
------------преобразование цифры в:
----------------* bool -> 0 или 1
----------------* char -> ASCII


----### Препроцессор - программа, которая проводит манипуляции с кодом до того, как он скомпилируется

----### Директивы
--------#### include - подключить библиотека/код
------------Структура: #include <lib> or <path_to_file>
------------Пример: include <iostream>
--------#### define - определить макрос
------------Структура: #define MACROS_NAME MACROS_VALUE
------------Пример: #define PI 3.14

----### Условная компиляция
--------#### Директивы
            ```
			if
			ifdef - if defined
			ifndef - if not defined
			endif - condition end
			else
			elif
            ```
--------#### Пример
            ```
			#ifdef PI
				cout << "PI number already defined" << endl;
			endif

			#if NUM > 255
				cout << "NUM more than 255" << endl;
			#elif  NUM == 255
				cout << "NUM equal to 255" << endl;
			#else
				cout << "NUM less than 255" << endl;
			endif
            ```

----### Передача параметров в программу при запуске
    ```
	    int argc, char* argv[]
    ```

----### Значение
--------argc - количество аргументов | минимальное количество аргументов - 1
--------argv - значение аргументов

----### Пример: int main(int argc, char* argv[]) {...}

---

## OOP - объектно-ориентированное программирование
----### Термины
--------* Наследование - наследование свойств и методов другого класса
--------* Инкапсуляция - сокрытыие данных для ограничения доступа к свойствам/методам класса
--------* Полиморфизм - 
--------* Класс - пользовательский тип данных
--------* Метод - функция класса
--------* Геттеры и Сеттеры - получить/установить данные. используются для взаимодействия с инкапсулированными данными
--------* Агрегация - класс может использоваться в разных классах
--------* Композиция - класс в классе предназначен только для внешнего класса (приватный)
--------* Интерфейс - абстрактный метод с чисто виртуальными методами

----### Ключевые слова
--------* virtual - нужен для переопределения реализации(поведения) метода в других классах
--------* override - нужен для контроля компилятором сигнатуры измененного метода


----### Класс
--------#### Объявление
            ```
            class ClassName
            {
            public:
                data_type value_name
            }
            ```

--------#### Инициализация
            ```
            ClassName example;
            ```

----### Абстрактный класс
--------#### Описание: класс не для создания экземпляра класса (объекта), а для наследования с свойствами и методами без описания поведения (реалзиации)
--------#### Объявление
            ```
            class ClassName
            {
            public:
                data_type value_name
                virtual data_type method_name = 0; - чистая виртуальная функция
            }
            ```

----### Наследование
--------#### Одиночное
            ```
            class ClassName {
            public:
                value_type value_name;
            }

            class NewClassName : public ClassName
            {
            public:
                value_type another_value_name;
            }
            ```
--------#### Множественное
            ```
            class A {
            public:
                value_type value_name;
            }

            class B
            {
            public:
                value_type another_value_name;
            }

            class C : public A, public B
            {
            public:
                value_type some_value_name;
            }
            ```

----### Дружественные классы
--------#### Объявление
            ```
            class FirstClass
            {
                ...
            }

            class SecondClass
            {
            private:
                int value = 10;
                friend FirstClass;
            }

            SecondClass a;
            FirstClass.a = 11;
            ```
----### this
--------#### Описание: константный указатель объекта на самого себя (адрес в памяти). Хранит ссылку на самого себя, благодаря чему можно получить доступ ко всем --------#### методам класса
--------#### Синтаксис: this->value | this->method

----### static
--------#### value
------------##### Описание: статические поля. при изменении значения в одном объекте, изменяются и в других, т.к. 1 свойство на несколько объектов (общая для всех)
------------##### Обращение
                ```
                object.static_value
                ClassName::static_value
                ```
------------##### Объявление
                ```
                class ClassName
                {
                public:
                    static data_type static_value;
                }
                ```
------------##### Инициализация
                ```
                data_type ClassName::static_value = value
                ```
--------#### method
------------##### Описание: используются для работы со статическими данными
------------##### Обращение:
                ```
                object.static_method();
                ClassName::static_method();
                ```
------------##### Объявление
                ```
                class ClassName
                {
                public:
                    static data_type static_method() {...}
                }
                ```
    
----### Конструктор
--------#### Класса
------------##### ClassName == ConstructorName
------------##### Описание: функция, которая вызывается при создании объекта класса. нет возвращаемых значений, можно перегружать, передавать аргументы
------------##### Объявление
                ```
                class ClassName
                {
                public:
                    value_type value_name;

                    ClassName(value_type added_value_name)
                    {
                        value_name = added_value_name;
                    }
                }
                ```
------------##### Перегрузка
                ```
                class ClassName
                {
                public:
                    int x;

                    ClassName(int valueX)
                    {
                        x = valueX;
                    }
                    ClassName(bool isOdd)
                    {
                        if (isOdd)
                        {
                            x = 10;
                        }
                    }
                    ClassName(string word)
                    {
                        x = sizeof(word);
                    }
                }
                ```
        
--------#### Копирования
------------##### Описание: копирование объектов
------------##### Объявление
                ```
                class ClassName
                {
                public:
                    value_type *value_name;

                    ClassName(const ClassName &object_name)
                    {
                        this->value_name = new value_type[object_name.size];				// не копируем тот же адрес указателя, а создаем новый с таким же количеством объектов в массиве
                        
                        for (int i = 0; i < object_name.size; i++)
                        {
                            this->value_name[i] = object_name.value_name[i];
                        }
                    }
                }
                ```

--------#### Делегирующие
------------##### Описание: для уменьшения кода путем добавления реализации к уже существующему конструктору
------------##### Объявление
                ```
                class Human
                {
                public:
                    Human(string name)
                    {
                        this->name = name;
                        this->age = 0;
                    }

                    Human(string name, int age) : Human(name)
                    {
                        this->age = age;
                    }
                private:
                    string name;
                    int age;
                }
                ```

----### Деструктор
--------#### ClassName == DestructorName
--------#### Описание: функция, которая вызывается автоматически при выходе объекта за область видимости, при уничтожении объекта
--------#### Объявление
            ```
            class ClassName
            {
            public:
                value_type value_name;

                ~ClassName(value_type added_value_name)
                {
                    value_name = added_value_name;
                }
            }
            ```
--------#### Синтаксис
            ~ - объявление деструктора

----### Методы
--------#### Объявление
------------##### В классе
----------------access_modifier data_type method_name(arguments) {...}
------------##### Вне класса
                ```
                class ClassName
                {
                    access_modifier data_type method_name(arguments);
                }
                ```

----------------data_type ClassName::method_name(arguments) {...}

----### Дружественные методы
--------#### Объявление
            ```
            class FirstClass
            {
                void showInfo(SecondClass& object);
            }

            class SecondClass
            {
            private:
                int value = 10;
                friend void FirstClass::showInfo(SecondClass& object);
            }

            void FirstClass::showInfo(SecondClass& object)
            {
                cout << object.value << endl;
            }
            ```
        
----### Модификаторы доступа
--------public - публичный доступ
--------private - доступ только внутри экземпляра класса
--------protected - доступ у класса и наследованных классах

----### Геттеры и Сеттеры
--------data_type get_value_name() { return value_name; } | int GetX() { return x;}
--------data_type set_value_name(data_type value_name) {  } | void SetX(int valueX) { x = valueX }

----### Перегрузка операторов
--------#### Описание: кастомизация операторов и описание действий при вызове оператора
--------#### Операторы: =
--------#### Синтаксис: ClassName & operator operator_view (const ClassName &object_name)
--------#### Объявление:
            ```
            class ClassName
            {
            public:
                value_type *value_name;

                ClassName & operator = (const ClassName &object_name)
                {
                    if (this->value_name != nullptr)
                    {
                        delete[] this->value_name;
                    }

                    this->value_name = new value_type[object_name.size];
                    
                    for (int i = 0; i < object_name.size; i++)
                    {
                        this->value_name[i] = object_name.value_name[i];
                    }

                    return *this;
                }
            }
            ```

----### Дружественные функции
--------#### Описание: фукнции с доступом к приватным полям класса
--------#### Синтаксис
------------friend дружественная_функция
--------#### Объявление
            ```
            class ClassName
            {
                friend data_type function_name(ClassName &object);
            }

            data_type function_name(ClassName &object)
            {
                object.value++;
            }
            ```

----### Примечание
--------* свойства и методы класса по умолчанию private
--------* префиксы get - геттер, set - сеттер
--------* конструктор класса создается по умолчанию
--------* нельзя создать объект класса, если данные не переданы при объявлении
--------* конструктор должен быть публичным
--------* перегрузка конструкторов - полиморфизм
--------* количество деструкторов не может быть больше 1
--------* деструктор не может быть с параметрами(аргументами)
--------* деструктор вызывается при выходе за область видимости
--------* освобождение динамической памяти в деструкторе
--------* при копировании объектов: ClassName a(n); ClassName b(a), копируется и адреса указателей, и при освобождении         динамической памяти в одном объекте, может быть ошибка, т.к. данные в тому же адресу памяти уже освобождены
--------* наиболее подходящее использование и объявление конструкторов копирования - работа с динамической памятью
--------* дружественные классы/методы могут получить доступ к приватным полям, что нарушает инкапсуляцию класса
--------* значение статических данных указываются вне класса
--------* статические методы не должны изменять значения класса
--------* в статических объектах нельзя обращаться к this
--------* виртуальный деструктор нужен для правильно освобождения ресурсов в наследованных классах
--------* вызов виртуального метода ::ClassName::virtual_method_name
--------* в c++ нет ключевого слова interface, поэтому интерфейс описывается как абстрактный класс
--------* виртуальное наследование нужно для того, чтобы конструктор не вызывался несколько раз